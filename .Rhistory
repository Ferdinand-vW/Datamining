split <- findSplit(x,y,minleaf)
#Determine whether a split was possible
if(!is.na(split[[1]])) {
n <- doSplit(x,y,split)
#Remove all unnecessary rows
lx <- x[x[split[[3]]] <= split[[1]], ]
rx <- x[x[split[[3]]] >  split[[1]], ]
#remove the column that was used for splitting
lx[split[[3]]] <- NULL
rx[split[[3]]] <- NULL
#There must be at least one more column to split on
if(length(colnames(lx)) >= 1) {
lChild <- tree.grow1(lx, n@lChild,nmin,minleaf)
n@lChild = lChild
}
#There must be at at least one more column to split on
if(length(colnames(rx)) >= 1) {
rChild <- tree.grow1(rx, n@rChild,nmin,minleaf)
n@rChild = rChild
}
return(n)
}
else {
}
}
else {
print("class labels have no length")
}
node
}
findSplit <- function(x,y,minleaf) {
splits <- lapply(x,FUN=findSplitAttribute,y=y,minleaf=minleaf)
bSplit <- NA
bgini <- NA
battr <- c("")
for(col in names(splits)) {
attr <- splits[[col]]
split <- attr[1]
gini <- attr[2]
if(!is.na(split)) {
if(is.na(bgini) || gini > bgini) {
bgini <- gini
bSplit <- split
battr <- col
}
}
}
list(bSplit,bgini,battr)
}
findSplitAttribute <- function(col,y,minleaf) {
bestsplit(col,y,minleaf)
}
doSplit <- function(x,y,split) {
splitVal <- split[[1]]
gini <- split[[2]]
splitAttr <- split[[3]]
lChild <- y[x[splitAttr] <= splitVal]
rChild <- y[x[splitAttr] > splitVal]
n <- newNode(y)
n@lChild = newNode(lChild)
n@rChild = newNode(rChild)
n@splitAttr = splitAttr
n@splitVal = splitVal
n
}
#
# #If a node and both children are leafs and have the same majority class
# #then remove the children and return the current node back as a leaf node
# #If a node but the children are not leaf nodes then recursively go into both the left
# #and right child
# #If the current node is a leaf node then simply return it
# tree.simplify <- function(tree) {
#   if(isNode(tree)) {
#     l <- leftChild(tree)
#     r <- rightChild(tree)
#
#     if(isLeaf(l) && isLeaf(r) && class(l) == class(r)) {
#       leaf(vaue(tree))
#     }
#     else {
#       l <- tree.simplify(l)
#       r <- tree.simplify(r)
#       node(l, value(tree), r)
#     }
#   }
#   else {
#     tree
#   }
# }
#
# tree.classify <- function(x,tr) {
#   y <- c(0)
#
#   foreach(sample s : x) {
#       y <- c(y, tree.classify1(s,tr))
#   }
#
#   y
# }
#
#
# #We check whether the tree is a node
# #If so we get the attribute that the node is split on
# #Furthermore we get the value that was used for splitting
# #Then we take the corresponding value of the training sample s
# #If that value is lower than the splitvalue we recursively go into the leftchild
# #otherwise into the rightchild
# #The base case is the leaf node, which returns the majority class of that leaf
# tree.classify1 <- function(s, tr) {
#   if(isNode(tr)) {
#     attr <- attribute(tr)
#     splitvalue <- split(tr)
#
#     val <- attributeValue(s, attr)
#     if (val <= splitvalue) {
#       l <- leftChild(tr)
#       tree.classify1(s, l)
#     }
#     else {
#       r <- rightChild(tr)
#       tree.classify1(s, r)
#     }
#   }
#   else {
#     classValue(tr)
#   }
# }
tree.grow(credit.dat,class,2,1)
setClass(
"Tree"
)
setClass(
"Node",
representation(lChild="Tree",
classLabels="numeric",
splitAttr="character",splitVal="numeric",
rChild="Tree"),
contains = "Tree"
)
setClass(
"Leaf",
contains = "Tree"
)
setGeneric("isLeaf",function(x) attributes(x))
setMethod("isLeaf","Tree",
function(x) {
class(x) == "Leaf"
})
setGeneric("isNode",function(x) attributes(x))
setMethod("isNode", "Tree",
function(x) {
class(x) == "Node"
})
newNode <- function(x) {
new("Node", lChild= new("Leaf"), classLabels=x, rChild=new("Leaf"))
}
bestsplit <- function(x,y,minleaf) {
sorted <- sort(unique(x))
splitpoints <- (sorted[1:length(sorted) - 1] + sorted[2:length(sorted)]) / 2
split <- foldSplits(x,y,splitpoints,minleaf)
c(split,computesplit(x,y,split,minleaf))
}
foldSplits <- function(x,y,splits,minleaf) {
Reduce(function(a,b) {
asplit <- computesplit(x,y,a,minleaf)
bsplit <- computesplit(x,y,b,minleaf)
if(!is.na(asplit) && !is.na(bsplit)) {
if(asplit > bsplit) {
a
}
else {
b
}
}
else if(!is.na(asplit)){
a
}
else if(!is.na(bsplit)){
b
}
else {
NA
}
}, splits, NA)
}
computesplit <- function(x, y, val,minleaf) {
if(!is.na(val)) {
lchild <- y [x <= val]
rchild <- y [x > val]
if(!canbeSplit(lchild, rchild,minleaf)) {
NA
}
else {
valOfChild(y,length(y)) - (valOfChild(lchild, length(x)) + valOfChild(rchild, length(x)))
}
}
else {
NA
}
}
canbeSplit <- function(l, r,minleaf) {
length(l) >= minleaf && length(r) >= minleaf
}
valOfChild <- function(x, n) {
num <- length(x) / n
pGood <- sum(x) / length(x)
pBad <- length(x[x==0]) / length(x)
num * pGood * pBad
}
tree.grow(credit.dat,class,2,1)
tree.grow(credit.dat,class,2,1)
?
)
exit
quit
end
exit()
quit()
help()
main()
Main.R
View(tree.grow)
View(tree.grow)
View(tree.grow1)
View(tree.grow1)
?"source
""
?"source"
?"source"
pwd
setwd
getwd()
setwd("/Users/rizkiyanto/GitHub/Datamining/")
tree.grow(credit.dat,class,2,1)
tree.grow(credit.dat,y,2,1)
tree.grow(credit.dat,"class",2,1)
credit.dat
?setClass
?"foldsplit"
?Reduce
add <- function(x) Reduce("+", x)
add(list(1, 2, 3))
?is.na
is.na(x)
NA
is.na(x)
is.na(c(1, NA))
is.na(paste(c(1, NA)))
(xx <- c(0:4))
is.na(xx) <- c(2, 4)
xx
anyNA(xx)
(xx <- c(0:4))
xx
is.na(xx)
is.na(xx) <- c(2, 4)
xx
is.na(xx)
?&&
?`&&`
root
?`@`
m <- matrix(1:6, nrow = 2, dimnames = list(c("a", "b"), LETTERS[1:3]))
m[1,]
m
m[1,]
m[1, , drop=FALSE]
m[2, , drop=FALSE]
m[2,]
m[,c(TRUE,FALSE,TRUE)]
m[cbind(c(1,2,1),3:1)]
m
?return
?clear screen
?screen
submit()
source('~/GitHub/Datamining/functions.R')
source('~/GitHub/Datamining/Main.R')
source('~/GitHub/Datamining/Tree.R')
credit.dat <- read.csv ('/Users/rizkiyanto/Downloads/0-Data Mining/Lab Session/Credit.txt')
tree.grow(credot.dat,class,2,1)
tree.grow(credit.dat,class,2,1)
credit.dat
tree.grow("credit.dat",class,2,1)
source('~/GitHub/Datamining/Simplify.R')
source('~/GitHub/Datamining/Simplify.R')
source('~/GitHub/Datamining/Simplify.R')
?isnode
?is.node
?setClass
?class
source('~/GitHub/Datamining/Simplify.R')
?setGeneric
?setClass
tree.grow("credit.dat","class",nmon=2,minleaf=1)
tree.grow("credit.dat","class",nmin=2,minleaf=1)
credit.dat
y <- credit.dat[,6]
y
credit.dat
credit.dat [,6] <- NULL
credit.dat
tree.grow(credit.dat,y,nmin=2,minleaf=1)
library(party)
set.seed(1234)
ind <- sample(2, nrow(iris), replace = TRUE, prob = c(0.7,0.3))
trainData <- iris[ind == 1,]
testData <- iris[ind == 2,]
myFormula <- Species ~ Sepal.Length + Sepal.Width + Petal.Length  + Petal.Width
iris_tree <- ctree(myFormula, data = trainData)
table(predict(iris_tree), trainData$Species)
iris_tree
tree1 <- tree.grow(credit.dat,y,nmin=2,minleaf=1)
tree1
tree1
test1 <- tree.grow(credit.dat,y,nmin=2,minleaf=1)
test1
source('~/GitHub/Datamining/Main.R')
source('~/GitHub/Datamining/Tree.R')
iris_tree
plot(iris_tree)
plot(tree1)
pima.dat <- csv.read ("/Users/rizkiyanto/Downloads/0-Data Mining/Lab Session/pima.txt")
pima.dat <- read.csv ("/Users/rizkiyanto/Downloads/0-Data Mining/Lab Session/pima.txt")
pima.dat
head(pima.dat)
str(pima.dat)
head(pima.dat)
z <- pima.dat[,9]
z
pima.dat[,9] <- NULL
tree3 <- tree.grow(pima.dat,z,20,5)
tree3
source('~/GitHub/Datamining/functions.R')
class(tree1)
class(iris_tree)
new("Node", lChild= new("Leaf"), classLabels=x, rChild=new("Leaf"))
newNode <- function(x) {
new("Node", lChild= new("Leaf"), classLabels=x, rChild=new("Leaf"))
}
newNode(x)
newNode(y)
newNode(z)
?setClass
?`@`
y
baru <- newnode(y)
baru <- newNode(y)
baru
root@classlabels
baru@classLabels
baru
baru@rChild
class(baru)
str(baru)
?new
1 <- new("track", x = seq_along(ydata), y = ydata)
?setMethod
?setGeneric
?attributes
attributes(baru)
class(test1)
test1
class(tree3)
baru
?lapply
?new
?setGeneric
?attributes
source('~/GitHub/Datamining/Simplify.R')
tree.simplify(tree1)
tree1
source('~/GitHub/Datamining/Simplify.R')
tree.simplify(tree1)
tree1
l <- tree1@lChild
l
l
source('~/GitHub/Datamining/Simplify.R')
source('~/GitHub/Datamining/Simplify.R')
source('~/GitHub/Datamining/Simplify.R')
tree.simplify(tree1)
l
tree3
test1
source('~/GitHub/Datamining/Simplify.R')
tree.simplify(tree1)
l
source('~/GitHub/Datamining/Simplify.R')
source('~/GitHub/Datamining/Simplify.R')
source('~/GitHub/Datamining/Simplify.R')
source('~/GitHub/Datamining/Simplify.R')
source('~/GitHub/Datamining/Simplify.R')
tree.simplify(tree1)
l
l <- NULL
l
tree.simplify(tree1)
tree1
y
tbaru <- tree.grow(credit.dat,y,2,1)
tbaru
str(tbaru)
class(tbaru)
str(tbaru)
?"str"
source('~/GitHub/Datamining/Main.R')
?setMethod
?attributes
?`==`
inc_tree <- ctree(class, data = credit.dat)
inc_tree <- ctree((class -.), data = credit.dat)
inc_tree <- ctree((class ~.), data = credit.dat)
?ctree
library(rpart)
inc_tree <- rpart(formula = Class ~ ., data=credit.dat)
credit.dat
credit.dat <- data.frame(credit.dat,y)
credit.dat
inc_tree <- rpart(formula = y ~ ., data=credit.dat)
inc_tree
?rpart
inc_tree <- rpart(formula = y ~ ., data=credit.dat,minbucket=1,minsplit=2)
inc_tree
inc_tree1 <- ctree(y ~., data = credit.dat)
inc_tree1
?ctree
inc_tree1 <- ctree(y ~ ., data=credit.dat,minbucket=1,minsplit=2)
inc_tree1 <- ctree(y ~ ., data=credit.dat,controls = ctree_control(minbucket=1,minsplit=2))
inc_tree1
inc_tree1 <- ctree(formula = y ~ ., data=credit.dat,controls = ctree_control(minbucket=1,minsplit=2))
inc_tree1
inc_tree
class(inc_tree)
source('~/GitHub/Datamining/Simplify.R')
tree1
str(tree1)
source('~/GitHub/Datamining/Simplify.R')
source('~/GitHub/Datamining/Simplify.R')
source('~/GitHub/Datamining/Simplify.R')
source('~/GitHub/Datamining/Simplify.R')
source('~/GitHub/Datamining/Simplify.R')
source('~/GitHub/Datamining/Tree.R')
source('~/GitHub/Datamining/Tree.R')
source('~/GitHub/Datamining/Simplify.R')
source('~/GitHub/Datamining/Simplify.R')
source('~/GitHub/Datamining/Simplify.R')
source('~/GitHub/Datamining/Simplify.R')
?mapply
?id
dt
mapply(dt,FUN=function(x){x})
tree
tree.classify(tree,dt)
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
source('C:/Users/Ferdinand/Datamining/classify.R')
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
source('C:/Users/Ferdinand/Datamining/classify.R')
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
source('C:/Users/Ferdinand/Datamining/classify.R')
source('C:/Users/Ferdinand/Datamining/classify.R')
source('C:/Users/Ferdinand/Datamining/classify.R')
?Reduce
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
source('C:/Users/Ferdinand/Datamining/classify.R')
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
source('C:/Users/Ferdinand/Datamining/classify.R')
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
dt
dt[1,]
dt
?rows
?data.frame
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
dt
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
dt
?apply
source('C:/Users/Ferdinand/Datamining/classify.R')
?apply
tree.classify(tree,dt)
source('C:/Users/Ferdinand/Datamining/classify.R')
source('C:/Users/Ferdinand/Datamining/classify.R')
source('C:/Users/Ferdinand/Datamining/classify.R')
tree.classify(tree,dt)
source('C:/Users/Ferdinand/Datamining/classify.R')
